Index: mutter-2.31.5/src/core/main.c
===================================================================
--- mutter-2.31.5.orig/src/core/main.c	2010-04-18 02:44:38.000000000 +0200
+++ mutter-2.31.5/src/core/main.c	2010-09-27 20:26:16.874972000 +0200
@@ -54,8 +54,11 @@
 #include "prefs.h"
 #include "compositor.h"
 
+#include <glib.h>
 #include <glib-object.h>
+#include <gdk/gdk.h>
 #include <gdk/gdkx.h>
+#include <gtk/gtk.h>
 
 #include <stdlib.h>
 #include <sys/types.h>
@@ -70,9 +73,16 @@
 #include <time.h>
 #include <unistd.h>
 
+#include <X11/Xlib.h>
+#include <X11/Xutil.h>
+#include <GL/gl.h>
+#include <GL/glx.h>
+
 #include <clutter/clutter.h>
 #include <clutter/x11/clutter-x11.h>
 
+#include <dbus/dbus-glib.h>
+
 #ifdef HAVE_INTROSPECTION
 #include <girepository.h>
 #include "compositor/mutter-plugin-manager.h"
@@ -469,6 +479,195 @@
   return FALSE;
 }
 
+/* take an optimistic approach: only return FALSE when we are sure it's FALSE */
+static gboolean
+rendering_available (void)
+{
+  char *displayName = NULL;
+  gchar *renderer = NULL;
+  Display *dpy;
+  int scrnum = 0;
+  Bool allowDirect = True;
+  Window win;
+  XSetWindowAttributes attr;
+  unsigned long mask;
+  Window root;
+  GLXContext ctx = NULL;
+  XVisualInfo *visinfo;
+  int width = 100, height = 100;
+  int attribSingle[] = {
+     GLX_RGBA,
+     GLX_RED_SIZE, 1,
+     GLX_GREEN_SIZE, 1,
+     GLX_BLUE_SIZE, 1,
+     None };
+  int attribDouble[] = {
+     GLX_RGBA,
+     GLX_RED_SIZE, 1,
+     GLX_GREEN_SIZE, 1,
+     GLX_BLUE_SIZE, 1,
+     GLX_DOUBLEBUFFER,
+     None };
+
+  dpy = XOpenDisplay(displayName); 
+  if (!dpy)
+   {
+    fprintf(stderr, "Error: unable to open display %s\n",
+XDisplayName(displayName));
+    return TRUE;
+   }
+  root = RootWindow(dpy, scrnum);
+  visinfo = glXChooseVisual(dpy, scrnum, attribSingle);
+  if (!visinfo)
+     visinfo = glXChooseVisual(dpy, scrnum, attribDouble);
+  if (visinfo)
+     ctx = glXCreateContext( dpy, visinfo, NULL, allowDirect );
+  if (!visinfo)
+   {
+      fprintf(stderr, "Error: couldn't find RGB GLX visual or fbconfig\n");
+      return TRUE;
+    }
+   if (!ctx)
+    {
+      fprintf(stderr, "Error: glXCreateContext failed\n");
+      XFree(visinfo);
+      return TRUE;
+    }
+
+   attr.background_pixel = 0;
+   attr.border_pixel = 0;
+   attr.colormap = XCreateColormap(dpy, root, visinfo->visual, AllocNone);
+   attr.event_mask = StructureNotifyMask | ExposureMask;
+   mask = CWBackPixel | CWBorderPixel | CWColormap | CWEventMask;
+
+   win = XCreateWindow(dpy, root, 0, 0, width, height,
+                       0, visinfo->depth, InputOutput,
+                       visinfo->visual, mask, &attr);
+   if (glXMakeCurrent(dpy, win, ctx))
+    {
+              g_warning ("3");
+      const char *glRenderer = (const char *) glGetString(GL_RENDERER);
+              g_warning ("5");
+      renderer = g_ascii_strdown (glRenderer, -1);
+              g_warning ("4");
+      g_debug ("OpenGL renderer string: %s\n", glRenderer);
+    }
+
+  if (renderer && (strstr (renderer, "software") != NULL))
+    return FALSE;
+
+  return TRUE;
+}
+
+static gboolean
+session_logout_success (void)
+{
+  GtkWidget* dialog_warn_logout;
+  gint response;
+
+  dialog_warn_logout = gtk_message_dialog_new (NULL,
+                                               GTK_DIALOG_MODAL,
+                                               GTK_MESSAGE_WARNING,
+                                               GTK_BUTTONS_OK,
+                                               _("No required driver detected for unity."));
+  gtk_message_dialog_format_secondary_markup (GTK_MESSAGE_DIALOG(dialog_warn_logout),
+                                              _("You will need to choose the Ubuntu Desktop session once you select your user name."));
+  response = gtk_dialog_run (GTK_DIALOG(dialog_warn_logout));
+  gtk_widget_destroy (dialog_warn_logout);
+
+  if (response == GTK_RESPONSE_OK || response == GTK_RESPONSE_DELETE_EVENT)
+    {
+      DBusGConnection * sbus;
+      DBusGProxy * sm_proxy;
+      GError * error = NULL;
+      gboolean res = FALSE;
+
+      // don't deliver the signal too soon or won't work
+      sleep (8);
+
+      sbus = dbus_g_bus_get(DBUS_BUS_SESSION, NULL);
+      if (sbus == NULL)
+        {
+          g_warning ("Unable to get DBus session bus.");
+          return FALSE;
+        }
+      sm_proxy = dbus_g_proxy_new_for_name_owner (sbus,
+                                                  "org.gnome.SessionManager",
+                                                  "/org/gnome/SessionManager",
+                                                  "org.gnome.SessionManager",
+                                                  &error);
+      if (sm_proxy == NULL)
+        {
+            g_warning ("Unable to get DBus proxy to SessionManager interface: %s", error->message);
+            g_error_free (error);
+            return FALSE;
+        }
+      g_clear_error (&error);
+
+      res = dbus_g_proxy_call_with_timeout (sm_proxy, "Logout", INT_MAX, &error,
+                                            G_TYPE_UINT, 1, G_TYPE_INVALID, G_TYPE_INVALID);
+      if (!res)
+        {
+          if (error != NULL)
+            g_warning ("SessionManager action failed: %s", error->message);
+          else
+            g_warning ("SessionManager action failed: unknown error");
+
+          g_object_unref(sm_proxy);
+          g_error_free(error);
+          return FALSE;
+         }
+
+    g_object_unref(sm_proxy);
+    g_warning ("logout");
+    return TRUE;
+  }
+  g_warning ("Logout denied, trying to start unity");
+  return FALSE;
+}
+
+static void
+change_user_session (const char *session_name)
+{
+
+  GKeyFile *key_file;
+  GError   *error;
+  char     *filename;
+  gsize     length;
+  gchar    *contents;
+
+  filename = g_build_filename (g_get_home_dir(), ".dmrc", NULL);
+  error = NULL;
+
+  key_file = g_key_file_new ();
+  g_key_file_load_from_file (key_file, filename,
+                             G_KEY_FILE_KEEP_COMMENTS |
+                             G_KEY_FILE_KEEP_TRANSLATIONS,
+                             NULL);
+  g_key_file_set_string (key_file, "Desktop", "Session",
+                         session_name);
+
+  contents = g_key_file_to_data (key_file, &length, &error);
+  if (contents == NULL)
+    {
+      g_debug ("Can't create content for .dmrc file: %s", error->message);
+      g_key_file_free (key_file);
+      g_free (filename);
+      return;
+    }
+
+  if (!g_file_set_contents (filename, contents, length, &error))
+    {
+      g_debug ("Can't update .dmrc file: %s", error->message);
+      g_error_free (error);
+    }
+
+   g_free (contents);
+   g_key_file_free (key_file);
+   g_free (filename);
+
+}
+
 /**
  * This is where the story begins. It parses commandline options and
  * environment variables, sets up the screen, hands control off to
@@ -548,6 +747,21 @@
   bind_textdomain_codeset (GETTEXT_PACKAGE, "UTF-8");
   textdomain (GETTEXT_PACKAGE);
 
+  if (g_strcmp0 (g_getenv ("GDMSESSION"), "une\0") == 0)
+	{
+	  g_warning ("1");
+	  if (!rendering_available ())
+		{
+	  g_warning ("2");
+		  g_warning ("No rendering avaible for unity, prompting for changing session");
+		  gtk_init (&argc, &argv);
+		  change_user_session ("gnome");
+		  // if we can't logout, fallback to trying to run unity...
+		  if (session_logout_success ())
+			exit (0); // 0 or will be respawn as required_component
+		 }
+     }
+
   /* Parse command line arguments.*/
   ctx = meta_parse_options (&argc, &argv, &meta_args);
 
Index: mutter-2.31.5/configure.in
===================================================================
--- mutter-2.31.5.orig/configure.in	2010-09-27 20:26:12.222972000 +0200
+++ mutter-2.31.5/configure.in	2010-09-27 20:26:12.470972000 +0200
@@ -145,7 +145,7 @@
        ;;
 esac
 
-MUTTER_PC_MODULES="gtk+-$GTK_API_VERSION >= $GTK_MIN_VERSION pango >= 1.2.0"
+MUTTER_PC_MODULES="gtk+-$GTK_API_VERSION >= $GTK_MIN_VERSION pango >= 1.2.0 dbus-1 dbus-glib-1"
 AC_SUBST(GTK_API_VERSION)
 
 AC_ARG_ENABLE(gconf,
